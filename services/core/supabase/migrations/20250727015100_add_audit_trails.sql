-- Audit trails for data tracking and compliance

-- Create audit log table
CREATE TABLE IF NOT EXISTS "public"."audit_logs" (
    "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    "table_name" TEXT NOT NULL,
    "record_id" TEXT NOT NULL,
    "operation" TEXT NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),
    "old_values" JSONB,
    "new_values" JSONB,
    "changed_fields" TEXT[],
    "user_id" UUID REFERENCES auth.users(id) ON DELETE SET NULL,
    "user_email" TEXT,
    "ip_address" INET,
    "user_agent" TEXT,
    "timestamp" TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,
    "source" TEXT DEFAULT 'database' -- 'database', 'api', 'admin', etc.
);

-- Create indexes for audit logs
CREATE INDEX IF NOT EXISTS "idx_audit_logs_table_record" ON "public"."audit_logs" USING btree ("table_name", "record_id");
CREATE INDEX IF NOT EXISTS "idx_audit_logs_timestamp" ON "public"."audit_logs" USING btree ("timestamp");
CREATE INDEX IF NOT EXISTS "idx_audit_logs_user" ON "public"."audit_logs" USING btree ("user_id");
CREATE INDEX IF NOT EXISTS "idx_audit_logs_operation" ON "public"."audit_logs" USING btree ("operation");
CREATE INDEX IF NOT EXISTS "idx_audit_logs_table" ON "public"."audit_logs" USING btree ("table_name");

-- Enable RLS for audit logs
ALTER TABLE "public"."audit_logs" ENABLE ROW LEVEL SECURITY;

-- Only admins and service role can access audit logs
CREATE POLICY "Admins can view audit logs" ON "public"."audit_logs"
    AS PERMISSIVE FOR SELECT TO authenticated 
    USING (
        EXISTS (
            SELECT 1 FROM "public"."user_profiles" 
            WHERE id = auth.uid() AND is_admin = true
        )
    );

-- Grant permissions
GRANT ALL ON TABLE "public"."audit_logs" TO "service_role";
GRANT SELECT ON TABLE "public"."audit_logs" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."audit_logs_id_seq" TO "service_role";

-- Generic audit trigger function
CREATE OR REPLACE FUNCTION public.audit_trigger_function()
RETURNS TRIGGER AS $$
DECLARE
    old_values JSONB := '{}';
    new_values JSONB := '{}';
    changed_fields TEXT[] := '{}';
    field_name TEXT;
BEGIN
    -- Get current user info (may be null for system operations)
    IF TG_OP = 'DELETE' THEN
        old_values := to_jsonb(OLD);
        
        INSERT INTO public.audit_logs (
            table_name, record_id, operation, old_values, 
            user_id, user_email, timestamp
        ) VALUES (
            TG_TABLE_NAME, 
            OLD.id::TEXT, 
            TG_OP, 
            old_values,
            auth.uid(),
            auth.email(),
            NOW()
        );
        
        RETURN OLD;
    END IF;
    
    IF TG_OP = 'INSERT' THEN
        new_values := to_jsonb(NEW);
        
        INSERT INTO public.audit_logs (
            table_name, record_id, operation, new_values,
            user_id, user_email, timestamp
        ) VALUES (
            TG_TABLE_NAME, 
            NEW.id::TEXT, 
            TG_OP, 
            new_values,
            auth.uid(),
            auth.email(),
            NOW()
        );
        
        RETURN NEW;
    END IF;
    
    IF TG_OP = 'UPDATE' THEN
        old_values := to_jsonb(OLD);
        new_values := to_jsonb(NEW);
        
        -- Find changed fields
        FOR field_name IN SELECT jsonb_object_keys(new_values) LOOP
            IF old_values->field_name IS DISTINCT FROM new_values->field_name THEN
                changed_fields := changed_fields || field_name;
            END IF;
        END LOOP;
        
        -- Only log if there were actual changes
        IF array_length(changed_fields, 1) > 0 THEN
            INSERT INTO public.audit_logs (
                table_name, record_id, operation, old_values, new_values, changed_fields,
                user_id, user_email, timestamp
            ) VALUES (
                TG_TABLE_NAME, 
                NEW.id::TEXT, 
                TG_OP, 
                old_values, 
                new_values, 
                changed_fields,
                auth.uid(),
                auth.email(),
                NOW()
            );
        END IF;
        
        RETURN NEW;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Add audit triggers to important tables
CREATE TRIGGER audit_events_trigger
    AFTER INSERT OR UPDATE OR DELETE ON "public"."events"
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_accounts_trigger
    AFTER INSERT OR UPDATE OR DELETE ON "public"."accounts"
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_location_trigger
    AFTER INSERT OR UPDATE OR DELETE ON "public"."locations"
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_category_trigger
    AFTER INSERT OR UPDATE OR DELETE ON "public"."categories"
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_organizers_trigger
    AFTER INSERT OR UPDATE OR DELETE ON "public"."organizers"
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

CREATE TRIGGER audit_user_profiles_trigger
    AFTER INSERT OR UPDATE OR DELETE ON "public"."user_profiles"
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();

-- Create view for simplified audit log queries
CREATE OR REPLACE VIEW "public"."audit_summary" AS
SELECT 
    al.id,
    al.table_name,
    al.record_id,
    al.operation,
    al.changed_fields,
    al.timestamp,
    up.display_name as user_name,
    al.user_email
FROM "public"."audit_logs" al
LEFT JOIN "public"."user_profiles" up ON al.user_id = up.id
ORDER BY al.timestamp DESC;

-- Grant access to the view
GRANT SELECT ON "public"."audit_summary" TO "authenticated";

-- Create function to get audit history for a specific record
CREATE OR REPLACE FUNCTION public.get_record_audit_history(
    p_table_name TEXT,
    p_record_id TEXT
)
RETURNS TABLE (
    id BIGINT,
    operation TEXT,
    changed_fields TEXT[],
    old_values JSONB,
    new_values JSONB,
    user_name TEXT,
    user_email TEXT,
    audit_timestamp TIMESTAMP WITH TIME ZONE
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        al.id,
        al.operation,
        al.changed_fields,
        al.old_values,
        al.new_values,
        up.display_name,
        al.user_email,
        al.timestamp as audit_timestamp
    FROM "public"."audit_logs" al
    LEFT JOIN "public"."user_profiles" up ON al.user_id = up.id
    WHERE al.table_name = p_table_name AND al.record_id = p_record_id
    ORDER BY al.timestamp DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION public.get_record_audit_history(TEXT, TEXT) TO "authenticated";